#!/bin/bash

#EECS 470 Project3/final project auto-regression test script
#Authors: Owen Hoffend and Bradley Baker
#Created on: 9/28/2020

#Output folder directories
DEF_SYN_DIR="syn_outputs"
DEF_SIM_DIR="sim_outputs"
DEF_SIM_TRUTH_DIR="sim_ground_truth"
DEF_SYN_TRUTH_DIR="sim_ground_truth"
DEF_TEST_DIR="test_progs"

#Regression Testing Variables
REG_PROGS_AS=()
EXCLUSION_LIST=()
REG_PROGS_C=(
    "quicksort.c"
    "insertionsort.c"
    "fc_forward.c"
    "matrix_mult_rec.c"
    "right_triangles.c"
)
first_build=true

#Colors!
LGREEN='\033[1;32m'
RED='\033[0;31m'
NC='\033[0m'

#Copy the desired output files into the output file directory
function save_outputs() {
    if [ $RUN_REG = false ]; then
        echo "Saving $file output"
    fi
    mkdir -p ${outdir}
    outfile=$(basename $file) 
    cp pipeline.out ./${outdir}/${outfile}.pipeline.out || CASE_PASS=false
    cp program.out ./${outdir}/${outfile}.program.out || CASE_PASS=false
    cp writeback.out ./${outdir}/${outfile}.writeback.out || CASE_PASS=false
}

#Compare the writeback.out and program.out files generated by the DUT to a ground truth version
function check_outputs() {
    if [ $RUN_REG = false ]; then
        echo "Checking $file output"
    fi
    writeback=$(basename $file).writeback.out
    program=$(basename $file).program.out
    WB_PASS=true
    PROG_PASS=true
    cmp -s ./${outdir}/${writeback} ./${truthdir}/${writeback} ||\
        WB_PASS=false
    cmp -s <(grep @@@ ./${outdir}/${program}) <(grep @@@ ./${truthdir}/${program}) ||\
        PROG_PASS=false
    if [ $WB_PASS = false ] || [ $PROG_PASS = false ]; then
        CASE_PASS=false
    fi
    if [ $CASE_PASS = true ]; then
        printf -- "Case ${file}: ${LGREEN}PASSED${NC}\n"
    else
        printf -- "Case ${file}: ${RED}FAILED${NC}\n"
        NUM_FAILED=$(( $NUM_FAILED+1 ))

        #Printout of diff on fail
        if [ $PRINT_DIFF = true ]; then
            printf "\nComparing writeback.out:\n"
            if test -f "writeback.out"; then
                if [ $WB_PASS = false ]; then
                    printf "${RED}---WRITEBACK.OUT DIFFERS--- ${NC}\n"
                    diff ./${outdir}/${writeback} ./${truthdir}/${writeback} 
                else
                    printf "${LGREEN}---WRITEBACK.OUT IS THE SAME--- ${NC}\n"
                fi
            else
                printf "${RED}WRITEBACK.OUT WAS NOT GENERATED. CHECK FOR VERILOG BUILD ERRORS (ERROR 255) ${NC}\n"
            fi
            printf "\nComparing program.out:\n"
            if test -f "program.out"; then
                if [ $PROG_PASS = false ]; then
                    printf "${RED}---PROGRAM.OUT DIFFERS---${NC}\n"
                    diff <(grep @@@ ./${outdir}/${program}) <(grep @@@ ./${truthdir}/${program})
                else
                    printf "${LGREEN}---PROGRAM.OUT IS THE SAME--- ${NC}\n"
                fi
            else
                printf "${RED}PROGRAM.OUT WAS NOT GENERATED. CHECK FOR VERILOG BUILD ERRORS (ERROR 255) ${NC}\n"
            fi
        fi
    fi
    TOTAL_CASES=$(( $TOTAL_CASES+1 ))
}

#Run the desired build mode - synthesis or simulation
function build_verilog() {
    
    if [ $RUN_REG = false ]; then
        echo "Building verilog and running $file"
    fi

    if [ $CREATE_GROUND_TRUTH = true ]; then
        make sim_truth >> $logfile
        truthdir=$DEF_SIM_TRUTH_DIR
    else
        if [ $SYNTH = true ]; then
            ./syn_simv | tee program.out >> $logfile
            outdir=$DEF_SYN_DIR
            truthdir=$DEF_SIM_TRUTH_DIR
        else
            if [ $first_build = true ]; then
                make sim >> $logfile
                first_build=0
            else
                ./simv | tee program.out >> $logfile
            fi
            outdir=$DEF_SIM_DIR
            truthdir=$DEF_SIM_TRUTH_DIR
        fi
    fi

    if [ $CREATE_GROUND_TRUTH = true ]; then
        if [ $RUN_REG = false ]; then
            echo "Creating ground truth for file: $file"
        fi
        outdir=$truthdir
    fi
}

#Clear some old outputs - prevents build failures from appearing to pass
function clear_outputs(){
    rm pipeline.out
    rm writeback.out
    rm program.out
}

function run_prog(){
    #Test for excluded files
    if [ $SINGLE_FILE = false ]; then
        for excluded in ${EXCLUSION_LIST[@]}; do
            if [[ $excluded == $(basename $file) ]]; then
                echo "Excluded $file"
                return
            fi
        done
    fi
    if test -f "program.mem"; then
        CREATE_GROUND_TRUTH=true
        clear_outputs
        build_verilog
        save_outputs
        CREATE_GROUND_TRUTH=false
        clear_outputs
        build_verilog
        CASE_PASS=true
        save_outputs
        check_outputs
    else
        printf -- "${RED}---SOURCE BUILD FAILED---${NC}\n"
        exit
    fi
}

function run_asm(){
    if [ $RUN_REG = false ]; then
        echo "Assembling $file"
    fi
    make assembly SOURCE=$file >> $logfile
    run_prog
}

function run_c(){
    if [ $RUN_REG = false ]; then
        echo "Compiling $file"
    fi
    make program SOURCE=$file >> $logfile
    run_prog
}

#Build and run all of the assembly programs
#Better for quick testing
function runall_asm(){
    echo "---Running assembly test cases---"
    logfile=runall_asm.log
    > $logfile
    for file in ./test_progs/*.s; do
        run_asm
    done
}

#Build and run all of the c programs
#WARNING: Some of these take quite a long time to run
function runall_c(){
    echo "---Running c code test cases---"
    logfile=runall_c.log
    > $logfile
    for file in ./test_progs/*.c; do
        run_c
    done
}

function runreg_asm(){
    echo "---Running assembly regression test cases---"
    logfile=runreg_asm.log
    > $logfile
    for file in ${REG_PROGS_AS[@]}; do
        file=${DEF_TEST_DIR}/${file}
        #$echo("RUNNING TEST: ", file)
        run_asm
    done
}

function runreg_c(){
    echo "---Running c regression test cases---"
    logfile=runreg_c.log
    > $logfile
    for file in ${REG_PROGS_C[@]}; do
        file=${DEF_TEST_DIR}/${file}
        #$echo("RUNNING TEST: ", file)
        run_c
    done
}

#Real script starts here!
#Some default options
RUN_ASM=false
RUN_C=false
SYNTH=false
SINGLE_FILE=false
PRINT_DIFF=false
RUN_REG=false
NUM_ASM_FAILED=0

#Kill the previous program.mem, in case there was a failed source build
rm program.mem

#Parse command line options
if [ $# -eq 0 ]; then #Just exit if no action is specified
    echo "No options specified. Use -a for asm or -c for c."
    exit
fi
while [[ $# -gt 0 ]]; do
    arg="$1"
    case $arg in
        -r|--reg) #Enable regression tests with working programs
        RUN_REG=true
        shift
        ;;
        -a|--asm) #Assembly test cases
        RUN_ASM=true
        shift
        ;;
        -c) #C test cases
        RUN_C=true
        shift
        ;;
        -s|--syn) #Test synthesis
        SYNTH=true
        shift
        ;;
        -f) #Single file mode
        SINGLE_FILE=true
        testfile="$2"
        shift
        shift
        ;;
        -d|--diff) #Enable diff printout with failing cases
        PRINT_DIFF=true
        shift
        ;;
        *) #Bad argument
        echo "Invalid option: $arg. Use -a for asm or -c for c."
        exit
        ;;
    esac
done

#Now run the tests!
NUM_FAILED=$(( 0 ))
TOTAL_CASES=$(( 0 ))
if [ $RUN_REG = true ]; then
    printf -- "REGRESSION TESTING: BEGIN\n"
    runreg_asm
    if [ $NUM_FAILED = 0 ]; then
        printf -- "REGRESSION TESTING: ${LGREEN}ASSEMBLY PASSED${NC}\n"
    else
        printf -- "REGRESSION TESTING: ${RED}ASSEMBLY FAILED${NC}\n"
    fi
    NUM_ASM_FAILED=$NUM_FAILED

    runreg_c
    if [ $NUM_FAILED = $NUM_ASM_FAILED ]; then
        printf -- "REGRESSION TESTING: ${LGREEN}C PASSED${NC}\n"
    else
        printf -- "REGRESSION TESTING: ${RED}C FAILED${NC}\n"
    fi

    if [ $NUM_FAILED = 0 ]; then
        printf -- "${LGREEN}REGRESSION TESTING: ALL PASSED${NC}\n"
    else
        printf -- "${RED}REGRESSION TESTING: ALL FAILED${NC}\n"
    fi
    
    exit
fi
if [ $SINGLE_FILE = true ]; then
    ext="${testfile##*.}"
    logfile=test_$(basename $testfile).log
    > $logfile 
    file=$testfile
    if [ "$ext" = "s" ]; then
        run_asm
    elif [ "$ext" = "c" ]; then
        run_c
    else
        echo "Incorrect file extension on single-file testcase"
        exit
    fi
else
    if [ $RUN_ASM = true ]; then
        runall_asm
    fi
    if [ $RUN_C = true ]; then
        runall_c
    fi
fi

#Printout the overall result of the tests
printf "\n Overall Results:\n"
if [ $NUM_FAILED = 0 ]; then
    printf -- "${LGREEN}---ALL CASES PASSED---\n"
else
    printf -- "${RED}---${NUM_FAILED} TEST CASES FAILED---\n"
fi
printf -- "---TOTAL CASES RAN: ${TOTAL_CASES}---${NC}\n"